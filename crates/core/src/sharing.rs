use anyhow::{Context, Result};

use crate::conversation::Thread;

const CF_PAGES_API: &str = "https://api.cloudflare.com/client/v4";

pub struct ShareConfig {
    pub cf_account_id: String,
    pub cf_api_token: String,
    pub project_name: String,
    pub domain: String,
}

impl ShareConfig {
    pub fn from_env() -> Option<Self> {
        let account_id = std::env::var("CF_ACCOUNT_ID").ok()?;
        let api_token = std::env::var("CF_API_TOKEN").ok()?;
        Some(Self {
            cf_account_id: account_id,
            cf_api_token: api_token,
            project_name: "nyzhi-share".to_string(),
            domain: "share.nyzhi.com".to_string(),
        })
    }
}

pub fn render_thread_html(thread: &Thread, title: &str, redact_secrets: bool) -> String {
    let mut messages_html = String::new();

    for msg in thread.messages() {
        let role = match msg.role {
            nyzhi_provider::Role::User => "user",
            nyzhi_provider::Role::Assistant => "assistant",
            nyzhi_provider::Role::System => "system",
            nyzhi_provider::Role::Tool => "tool",
        };

        let raw_content = match &msg.content {
            nyzhi_provider::MessageContent::Text(t) => t.clone(),
            nyzhi_provider::MessageContent::Parts(parts) => parts
                .iter()
                .filter_map(|p| match p {
                    nyzhi_provider::ContentPart::Text { text } => Some(text.as_str()),
                    _ => None,
                })
                .collect::<Vec<_>>()
                .join(""),
        };

        let content = if redact_secrets {
            redact(&raw_content)
        } else {
            html_escape(&raw_content)
        };

        let role_class = role;
        let role_label = match role {
            "user" => "You",
            "assistant" => "Nizzy",
            "system" => "System",
            "tool" => "Tool",
            _ => role,
        };

        messages_html.push_str(&format!(
            r#"<div class="message {role_class}">
  <div class="role">{role_label}</div>
  <div class="content"><pre>{content}</pre></div>
</div>
"#
        ));
    }

    let title_escaped = html_escape(title);
    format!(
        r#"<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>{title_escaped} - nyzhi</title>
<style>
:root {{
  --bg: #0d1117;
  --fg: #c9d1d9;
  --accent: #58a6ff;
  --user-bg: #161b22;
  --assistant-bg: #1c2128;
  --system-bg: #1a1e24;
  --border: #30363d;
}}
* {{ box-sizing: border-box; margin: 0; padding: 0; }}
body {{
  background: var(--bg);
  color: var(--fg);
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
  line-height: 1.6;
  max-width: 900px;
  margin: 0 auto;
  padding: 2rem 1rem;
}}
h1 {{
  color: var(--accent);
  font-size: 1.5rem;
  margin-bottom: 0.5rem;
}}
.meta {{
  color: #8b949e;
  font-size: 0.85rem;
  margin-bottom: 2rem;
  border-bottom: 1px solid var(--border);
  padding-bottom: 1rem;
}}
.message {{
  border-radius: 8px;
  padding: 1rem;
  margin-bottom: 1rem;
}}
.message.user {{ background: var(--user-bg); border-left: 3px solid var(--accent); }}
.message.assistant {{ background: var(--assistant-bg); border-left: 3px solid #7ee787; }}
.message.system {{ background: var(--system-bg); border-left: 3px solid #d2a8ff; }}
.message.tool {{ background: var(--system-bg); border-left: 3px solid #f0883e; }}
.role {{
  font-weight: 600;
  font-size: 0.85rem;
  color: #8b949e;
  margin-bottom: 0.5rem;
  text-transform: uppercase;
  letter-spacing: 0.05em;
}}
.content pre {{
  white-space: pre-wrap;
  word-wrap: break-word;
  font-family: 'SF Mono', 'Fira Code', monospace;
  font-size: 0.9rem;
}}
.footer {{
  margin-top: 2rem;
  padding-top: 1rem;
  border-top: 1px solid var(--border);
  color: #8b949e;
  font-size: 0.8rem;
  text-align: center;
}}
.footer a {{ color: var(--accent); text-decoration: none; }}
</style>
</head>
<body>
<h1>{title_escaped}</h1>
<div class="meta">Shared from <a href="https://nyzhi.com">nyzhi</a></div>
{messages_html}
<div class="footer">
  Generated by <a href="https://nyzhi.com">nyzhi</a>
</div>
</body>
</html>"#
    )
}

/// Upload a single-file site to Cloudflare Pages via Direct Upload API.
pub async fn upload_to_cf_pages(
    config: &ShareConfig,
    html_content: &str,
    share_id: &str,
) -> Result<String> {
    let client = reqwest::Client::new();

    let file_part = reqwest::multipart::Part::bytes(html_content.as_bytes().to_vec())
        .file_name("index.html")
        .mime_str("text/html")?;

    let form = reqwest::multipart::Form::new().part("index.html", file_part);

    let url = format!(
        "{CF_PAGES_API}/accounts/{}/pages/projects/{}/deployments",
        config.cf_account_id, config.project_name
    );

    let resp = client
        .post(&url)
        .header("Authorization", format!("Bearer {}", config.cf_api_token))
        .multipart(form)
        .send()
        .await
        .context("CF Pages upload failed")?;

    let status = resp.status();
    let body: serde_json::Value = resp.json().await.context("Failed to parse CF response")?;

    if !status.is_success() {
        let errors = body
            .get("errors")
            .and_then(|e| serde_json::to_string(e).ok())
            .unwrap_or_else(|| "unknown error".to_string());
        anyhow::bail!("CF Pages upload error ({}): {}", status, errors);
    }

    let deployment_url = body
        .pointer("/result/url")
        .and_then(|v| v.as_str())
        .map(String::from)
        .unwrap_or_else(|| format!("https://{}/{share_id}", config.domain));

    Ok(deployment_url)
}

/// Generate a shareable HTML file locally (no cloud upload).
pub fn export_share_local(thread: &Thread, output_dir: &std::path::Path, title: &str) -> Result<std::path::PathBuf> {
    let html = render_thread_html(thread, title, true);
    let share_id = &uuid::Uuid::new_v4().to_string()[..8];
    let filename = format!("share-{share_id}.html");
    let path = output_dir.join(&filename);
    std::fs::write(&path, &html).context("Failed to write share HTML")?;
    Ok(path)
}

fn html_escape(s: &str) -> String {
    s.replace('&', "&amp;")
        .replace('<', "&lt;")
        .replace('>', "&gt;")
        .replace('"', "&quot;")
}

fn redact(s: &str) -> String {
    let escaped = html_escape(s);
    let patterns = [
        "sk-", "xoxb-", "xoxp-", "ghp_", "gho_", "glpat-", "AKIA",
        "AIza", "Bearer ", "token=", "password=", "secret=",
    ];

    let mut result = escaped;
    for pattern in &patterns {
        while let Some(pos) = result.find(pattern) {
            let end = result[pos..]
                .find(|c: char| c.is_whitespace() || c == '"' || c == '\'' || c == '&')
                .map(|i| pos + i)
                .unwrap_or(result.len());
            let replacement = format!("{}[REDACTED]", &result[pos..pos + pattern.len()]);
            result.replace_range(pos..end, &replacement);
        }
    }
    result
}
